{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SpacePacketParser = void 0;\nconst stream_1 = require(\"stream\");\nconst utils_1 = require(\"./utils\");\n/**\n * A Transform stream that accepts a stream of octet data and converts it into an object\n * representation of a CCSDS Space Packet. See https://public.ccsds.org/Pubs/133x0b2e1.pdf for a\n * description of the Space Packet format.\n */\nclass SpacePacketParser extends stream_1.Transform {\n  /**\n   * A Transform stream that accepts a stream of octet data and emits object representations of\n   * CCSDS Space Packets once a packet has been completely received.\n   * @param {Object} [options] Configuration options for the stream\n   * @param {Number} options.timeCodeFieldLength The length of the time code field within the data\n   * @param {Number} options.ancillaryDataFieldLength The length of the ancillary data field within the data\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      ...options,\n      objectMode: true\n    });\n    // Set the constants for this Space Packet Connection; these will help us parse incoming data\n    // fields:\n    this.timeCodeFieldLength = options.timeCodeFieldLength || 0;\n    this.ancillaryDataFieldLength = options.ancillaryDataFieldLength || 0;\n    this.dataSlice = this.timeCodeFieldLength + this.ancillaryDataFieldLength;\n    // These are stateful based on the current packet being received:\n    this.dataBuffer = Buffer.alloc(0);\n    this.headerBuffer = Buffer.alloc(0);\n    this.dataLength = 0;\n    this.expectingHeader = true;\n  }\n  /**\n   * Bundle the header, secondary header if present, and the data into a JavaScript object to emit.\n   * If more data has been received past the current packet, begin the process of parsing the next\n   * packet(s).\n   */\n  pushCompletedPacket() {\n    if (!this.header) {\n      throw new Error('Missing header');\n    }\n    const timeCode = Buffer.from(this.dataBuffer.slice(0, this.timeCodeFieldLength));\n    const ancillaryData = Buffer.from(this.dataBuffer.slice(this.timeCodeFieldLength, this.timeCodeFieldLength + this.ancillaryDataFieldLength));\n    const data = Buffer.from(this.dataBuffer.slice(this.dataSlice, this.dataLength));\n    const completedPacket = {\n      header: {\n        ...this.header\n      },\n      data: data.toString()\n    };\n    if (timeCode.length > 0 || ancillaryData.length > 0) {\n      completedPacket.secondaryHeader = {};\n      if (timeCode.length) {\n        completedPacket.secondaryHeader.timeCode = timeCode.toString();\n      }\n      if (ancillaryData.length) {\n        completedPacket.secondaryHeader.ancillaryData = ancillaryData.toString();\n      }\n    }\n    this.push(completedPacket);\n    // If there is an overflow (i.e. we have more data than the packet we just pushed) begin parsing\n    // the next packet.\n    const nextChunk = Buffer.from(this.dataBuffer.slice(this.dataLength));\n    if (nextChunk.length >= utils_1.HEADER_LENGTH) {\n      this.extractHeader(nextChunk);\n    } else {\n      this.headerBuffer = nextChunk;\n      this.dataBuffer = Buffer.alloc(0);\n      this.expectingHeader = true;\n      this.dataLength = 0;\n      this.header = undefined;\n    }\n  }\n  /**\n   * Build the Stream's headerBuffer property from the received Buffer chunk; extract data from it\n   * if it's complete. If there's more to the chunk than just the header, initiate handling the\n   * packet data.\n   * @param chunk -  Build the Stream's headerBuffer property from\n   */\n  extractHeader(chunk) {\n    const headerAsBuffer = Buffer.concat([this.headerBuffer, chunk]);\n    const startOfDataBuffer = headerAsBuffer.slice(utils_1.HEADER_LENGTH);\n    if (headerAsBuffer.length >= utils_1.HEADER_LENGTH) {\n      this.header = (0, utils_1.convertHeaderBufferToObj)(headerAsBuffer);\n      this.dataLength = this.header.dataLength;\n      this.headerBuffer = Buffer.alloc(0);\n      this.expectingHeader = false;\n    } else {\n      this.headerBuffer = headerAsBuffer;\n    }\n    if (startOfDataBuffer.length > 0) {\n      this.dataBuffer = Buffer.from(startOfDataBuffer);\n      if (this.dataBuffer.length >= this.dataLength) {\n        this.pushCompletedPacket();\n      }\n    }\n  }\n  _transform(chunk, encoding, cb) {\n    if (this.expectingHeader) {\n      this.extractHeader(chunk);\n    } else {\n      this.dataBuffer = Buffer.concat([this.dataBuffer, chunk]);\n      if (this.dataBuffer.length >= this.dataLength) {\n        this.pushCompletedPacket();\n      }\n    }\n    cb();\n  }\n  _flush(cb) {\n    const remaining = Buffer.concat([this.headerBuffer, this.dataBuffer]);\n    const remainingArray = Array.from(remaining);\n    this.push(remainingArray);\n    cb();\n  }\n}\nexports.SpacePacketParser = SpacePacketParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","SpacePacketParser","stream_1","require","utils_1","Transform","constructor","options","objectMode","timeCodeFieldLength","ancillaryDataFieldLength","dataSlice","dataBuffer","Buffer","alloc","headerBuffer","dataLength","expectingHeader","pushCompletedPacket","header","Error","timeCode","from","slice","ancillaryData","data","completedPacket","toString","length","secondaryHeader","push","nextChunk","HEADER_LENGTH","extractHeader","undefined","chunk","headerAsBuffer","concat","startOfDataBuffer","convertHeaderBufferToObj","_transform","encoding","cb","_flush","remaining","remainingArray","Array"],"sources":["/Users/code/Desktop/WEB/lab-sistemas/frontend/node_modules/@serialport/parser-spacepacket/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpacePacketParser = void 0;\nconst stream_1 = require(\"stream\");\nconst utils_1 = require(\"./utils\");\n/**\n * A Transform stream that accepts a stream of octet data and converts it into an object\n * representation of a CCSDS Space Packet. See https://public.ccsds.org/Pubs/133x0b2e1.pdf for a\n * description of the Space Packet format.\n */\nclass SpacePacketParser extends stream_1.Transform {\n    /**\n     * A Transform stream that accepts a stream of octet data and emits object representations of\n     * CCSDS Space Packets once a packet has been completely received.\n     * @param {Object} [options] Configuration options for the stream\n     * @param {Number} options.timeCodeFieldLength The length of the time code field within the data\n     * @param {Number} options.ancillaryDataFieldLength The length of the ancillary data field within the data\n     */\n    constructor(options = {}) {\n        super({ ...options, objectMode: true });\n        // Set the constants for this Space Packet Connection; these will help us parse incoming data\n        // fields:\n        this.timeCodeFieldLength = options.timeCodeFieldLength || 0;\n        this.ancillaryDataFieldLength = options.ancillaryDataFieldLength || 0;\n        this.dataSlice = this.timeCodeFieldLength + this.ancillaryDataFieldLength;\n        // These are stateful based on the current packet being received:\n        this.dataBuffer = Buffer.alloc(0);\n        this.headerBuffer = Buffer.alloc(0);\n        this.dataLength = 0;\n        this.expectingHeader = true;\n    }\n    /**\n     * Bundle the header, secondary header if present, and the data into a JavaScript object to emit.\n     * If more data has been received past the current packet, begin the process of parsing the next\n     * packet(s).\n     */\n    pushCompletedPacket() {\n        if (!this.header) {\n            throw new Error('Missing header');\n        }\n        const timeCode = Buffer.from(this.dataBuffer.slice(0, this.timeCodeFieldLength));\n        const ancillaryData = Buffer.from(this.dataBuffer.slice(this.timeCodeFieldLength, this.timeCodeFieldLength + this.ancillaryDataFieldLength));\n        const data = Buffer.from(this.dataBuffer.slice(this.dataSlice, this.dataLength));\n        const completedPacket = {\n            header: { ...this.header },\n            data: data.toString(),\n        };\n        if (timeCode.length > 0 || ancillaryData.length > 0) {\n            completedPacket.secondaryHeader = {};\n            if (timeCode.length) {\n                completedPacket.secondaryHeader.timeCode = timeCode.toString();\n            }\n            if (ancillaryData.length) {\n                completedPacket.secondaryHeader.ancillaryData = ancillaryData.toString();\n            }\n        }\n        this.push(completedPacket);\n        // If there is an overflow (i.e. we have more data than the packet we just pushed) begin parsing\n        // the next packet.\n        const nextChunk = Buffer.from(this.dataBuffer.slice(this.dataLength));\n        if (nextChunk.length >= utils_1.HEADER_LENGTH) {\n            this.extractHeader(nextChunk);\n        }\n        else {\n            this.headerBuffer = nextChunk;\n            this.dataBuffer = Buffer.alloc(0);\n            this.expectingHeader = true;\n            this.dataLength = 0;\n            this.header = undefined;\n        }\n    }\n    /**\n     * Build the Stream's headerBuffer property from the received Buffer chunk; extract data from it\n     * if it's complete. If there's more to the chunk than just the header, initiate handling the\n     * packet data.\n     * @param chunk -  Build the Stream's headerBuffer property from\n     */\n    extractHeader(chunk) {\n        const headerAsBuffer = Buffer.concat([this.headerBuffer, chunk]);\n        const startOfDataBuffer = headerAsBuffer.slice(utils_1.HEADER_LENGTH);\n        if (headerAsBuffer.length >= utils_1.HEADER_LENGTH) {\n            this.header = (0, utils_1.convertHeaderBufferToObj)(headerAsBuffer);\n            this.dataLength = this.header.dataLength;\n            this.headerBuffer = Buffer.alloc(0);\n            this.expectingHeader = false;\n        }\n        else {\n            this.headerBuffer = headerAsBuffer;\n        }\n        if (startOfDataBuffer.length > 0) {\n            this.dataBuffer = Buffer.from(startOfDataBuffer);\n            if (this.dataBuffer.length >= this.dataLength) {\n                this.pushCompletedPacket();\n            }\n        }\n    }\n    _transform(chunk, encoding, cb) {\n        if (this.expectingHeader) {\n            this.extractHeader(chunk);\n        }\n        else {\n            this.dataBuffer = Buffer.concat([this.dataBuffer, chunk]);\n            if (this.dataBuffer.length >= this.dataLength) {\n                this.pushCompletedPacket();\n            }\n        }\n        cb();\n    }\n    _flush(cb) {\n        const remaining = Buffer.concat([this.headerBuffer, this.dataBuffer]);\n        const remainingArray = Array.from(remaining);\n        this.push(remainingArray);\n        cb();\n    }\n}\nexports.SpacePacketParser = SpacePacketParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}