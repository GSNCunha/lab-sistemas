{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReadyParser = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that waits for a sequence of \"ready\" bytes before emitting a ready event and emitting data events\n *\n * To use the `Ready` parser provide a byte start sequence. After the bytes have been received a ready event is fired and data events are passed through.\n */\nclass ReadyParser extends stream_1.Transform {\n  constructor(_ref) {\n    let {\n      delimiter,\n      ...options\n    } = _ref;\n    if (delimiter === undefined) {\n      throw new TypeError('\"delimiter\" is not a bufferable object');\n    }\n    if (delimiter.length === 0) {\n      throw new TypeError('\"delimiter\" has a 0 or undefined length');\n    }\n    super(options);\n    this.delimiter = Buffer.from(delimiter);\n    this.readOffset = 0;\n    this.ready = false;\n  }\n  _transform(chunk, encoding, cb) {\n    if (this.ready) {\n      this.push(chunk);\n      return cb();\n    }\n    const delimiter = this.delimiter;\n    let chunkOffset = 0;\n    while (this.readOffset < delimiter.length && chunkOffset < chunk.length) {\n      if (delimiter[this.readOffset] === chunk[chunkOffset]) {\n        this.readOffset++;\n      } else {\n        this.readOffset = 0;\n      }\n      chunkOffset++;\n    }\n    if (this.readOffset === delimiter.length) {\n      this.ready = true;\n      this.emit('ready');\n      const chunkRest = chunk.slice(chunkOffset);\n      if (chunkRest.length > 0) {\n        this.push(chunkRest);\n      }\n    }\n    cb();\n  }\n}\nexports.ReadyParser = ReadyParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","ReadyParser","stream_1","require","Transform","constructor","delimiter","options","undefined","TypeError","length","Buffer","from","readOffset","ready","_transform","chunk","encoding","cb","push","chunkOffset","emit","chunkRest","slice"],"sources":["/Users/code/Desktop/WEB/lab-sistemas/frontend/node_modules/@serialport/parser-ready/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadyParser = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that waits for a sequence of \"ready\" bytes before emitting a ready event and emitting data events\n *\n * To use the `Ready` parser provide a byte start sequence. After the bytes have been received a ready event is fired and data events are passed through.\n */\nclass ReadyParser extends stream_1.Transform {\n    constructor({ delimiter, ...options }) {\n        if (delimiter === undefined) {\n            throw new TypeError('\"delimiter\" is not a bufferable object');\n        }\n        if (delimiter.length === 0) {\n            throw new TypeError('\"delimiter\" has a 0 or undefined length');\n        }\n        super(options);\n        this.delimiter = Buffer.from(delimiter);\n        this.readOffset = 0;\n        this.ready = false;\n    }\n    _transform(chunk, encoding, cb) {\n        if (this.ready) {\n            this.push(chunk);\n            return cb();\n        }\n        const delimiter = this.delimiter;\n        let chunkOffset = 0;\n        while (this.readOffset < delimiter.length && chunkOffset < chunk.length) {\n            if (delimiter[this.readOffset] === chunk[chunkOffset]) {\n                this.readOffset++;\n            }\n            else {\n                this.readOffset = 0;\n            }\n            chunkOffset++;\n        }\n        if (this.readOffset === delimiter.length) {\n            this.ready = true;\n            this.emit('ready');\n            const chunkRest = chunk.slice(chunkOffset);\n            if (chunkRest.length > 0) {\n                this.push(chunkRest);\n            }\n        }\n        cb();\n    }\n}\nexports.ReadyParser = ReadyParser;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,WAAW,GAAG,KAAK,CAAC;AAC5B,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA,MAAMF,WAAW,SAASC,QAAQ,CAACE,SAAS,CAAC;EACzCC,WAAW,OAA4B;IAAA,IAA3B;MAAEC,SAAS;MAAE,GAAGC;IAAQ,CAAC;IACjC,IAAID,SAAS,KAAKE,SAAS,EAAE;MACzB,MAAM,IAAIC,SAAS,CAAC,wCAAwC,CAAC;IACjE;IACA,IAAIH,SAAS,CAACI,MAAM,KAAK,CAAC,EAAE;MACxB,MAAM,IAAID,SAAS,CAAC,yCAAyC,CAAC;IAClE;IACA,KAAK,CAACF,OAAO,CAAC;IACd,IAAI,CAACD,SAAS,GAAGK,MAAM,CAACC,IAAI,CAACN,SAAS,CAAC;IACvC,IAAI,CAACO,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,KAAK,GAAG,KAAK;EACtB;EACAC,UAAU,CAACC,KAAK,EAAEC,QAAQ,EAAEC,EAAE,EAAE;IAC5B,IAAI,IAAI,CAACJ,KAAK,EAAE;MACZ,IAAI,CAACK,IAAI,CAACH,KAAK,CAAC;MAChB,OAAOE,EAAE,EAAE;IACf;IACA,MAAMZ,SAAS,GAAG,IAAI,CAACA,SAAS;IAChC,IAAIc,WAAW,GAAG,CAAC;IACnB,OAAO,IAAI,CAACP,UAAU,GAAGP,SAAS,CAACI,MAAM,IAAIU,WAAW,GAAGJ,KAAK,CAACN,MAAM,EAAE;MACrE,IAAIJ,SAAS,CAAC,IAAI,CAACO,UAAU,CAAC,KAAKG,KAAK,CAACI,WAAW,CAAC,EAAE;QACnD,IAAI,CAACP,UAAU,EAAE;MACrB,CAAC,MACI;QACD,IAAI,CAACA,UAAU,GAAG,CAAC;MACvB;MACAO,WAAW,EAAE;IACjB;IACA,IAAI,IAAI,CAACP,UAAU,KAAKP,SAAS,CAACI,MAAM,EAAE;MACtC,IAAI,CAACI,KAAK,GAAG,IAAI;MACjB,IAAI,CAACO,IAAI,CAAC,OAAO,CAAC;MAClB,MAAMC,SAAS,GAAGN,KAAK,CAACO,KAAK,CAACH,WAAW,CAAC;MAC1C,IAAIE,SAAS,CAACZ,MAAM,GAAG,CAAC,EAAE;QACtB,IAAI,CAACS,IAAI,CAACG,SAAS,CAAC;MACxB;IACJ;IACAJ,EAAE,EAAE;EACR;AACJ;AACAnB,OAAO,CAACE,WAAW,GAAGA,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}