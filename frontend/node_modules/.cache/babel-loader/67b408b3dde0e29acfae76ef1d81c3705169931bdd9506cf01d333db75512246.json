{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InterByteTimeoutParser = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that buffers data and emits it after not receiving any bytes for the specified amount of time or hitting a max buffer size.\n */\nclass InterByteTimeoutParser extends stream_1.Transform {\n  constructor(_ref) {\n    let {\n      maxBufferSize = 65536,\n      interval,\n      ...transformOptions\n    } = _ref;\n    super(transformOptions);\n    if (!interval) {\n      throw new TypeError('\"interval\" is required');\n    }\n    if (typeof interval !== 'number' || Number.isNaN(interval)) {\n      throw new TypeError('\"interval\" is not a number');\n    }\n    if (interval < 1) {\n      throw new TypeError('\"interval\" is not greater than 0');\n    }\n    if (typeof maxBufferSize !== 'number' || Number.isNaN(maxBufferSize)) {\n      throw new TypeError('\"maxBufferSize\" is not a number');\n    }\n    if (maxBufferSize < 1) {\n      throw new TypeError('\"maxBufferSize\" is not greater than 0');\n    }\n    this.maxBufferSize = maxBufferSize;\n    this.currentPacket = [];\n    this.interval = interval;\n  }\n  _transform(chunk, encoding, cb) {\n    if (this.intervalID) {\n      clearTimeout(this.intervalID);\n    }\n    for (let offset = 0; offset < chunk.length; offset++) {\n      this.currentPacket.push(chunk[offset]);\n      if (this.currentPacket.length >= this.maxBufferSize) {\n        this.emitPacket();\n      }\n    }\n    this.intervalID = setTimeout(this.emitPacket.bind(this), this.interval);\n    cb();\n  }\n  emitPacket() {\n    if (this.intervalID) {\n      clearTimeout(this.intervalID);\n    }\n    if (this.currentPacket.length > 0) {\n      this.push(Buffer.from(this.currentPacket));\n    }\n    this.currentPacket = [];\n  }\n  _flush(cb) {\n    this.emitPacket();\n    cb();\n  }\n}\nexports.InterByteTimeoutParser = InterByteTimeoutParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","InterByteTimeoutParser","stream_1","require","Transform","constructor","maxBufferSize","interval","transformOptions","TypeError","Number","isNaN","currentPacket","_transform","chunk","encoding","cb","intervalID","clearTimeout","offset","length","push","emitPacket","setTimeout","bind","Buffer","from","_flush"],"sources":["/Users/code/Desktop/WEB/lab-sistemas/frontend/node_modules/@serialport/parser-inter-byte-timeout/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InterByteTimeoutParser = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that buffers data and emits it after not receiving any bytes for the specified amount of time or hitting a max buffer size.\n */\nclass InterByteTimeoutParser extends stream_1.Transform {\n    constructor({ maxBufferSize = 65536, interval, ...transformOptions }) {\n        super(transformOptions);\n        if (!interval) {\n            throw new TypeError('\"interval\" is required');\n        }\n        if (typeof interval !== 'number' || Number.isNaN(interval)) {\n            throw new TypeError('\"interval\" is not a number');\n        }\n        if (interval < 1) {\n            throw new TypeError('\"interval\" is not greater than 0');\n        }\n        if (typeof maxBufferSize !== 'number' || Number.isNaN(maxBufferSize)) {\n            throw new TypeError('\"maxBufferSize\" is not a number');\n        }\n        if (maxBufferSize < 1) {\n            throw new TypeError('\"maxBufferSize\" is not greater than 0');\n        }\n        this.maxBufferSize = maxBufferSize;\n        this.currentPacket = [];\n        this.interval = interval;\n    }\n    _transform(chunk, encoding, cb) {\n        if (this.intervalID) {\n            clearTimeout(this.intervalID);\n        }\n        for (let offset = 0; offset < chunk.length; offset++) {\n            this.currentPacket.push(chunk[offset]);\n            if (this.currentPacket.length >= this.maxBufferSize) {\n                this.emitPacket();\n            }\n        }\n        this.intervalID = setTimeout(this.emitPacket.bind(this), this.interval);\n        cb();\n    }\n    emitPacket() {\n        if (this.intervalID) {\n            clearTimeout(this.intervalID);\n        }\n        if (this.currentPacket.length > 0) {\n            this.push(Buffer.from(this.currentPacket));\n        }\n        this.currentPacket = [];\n    }\n    _flush(cb) {\n        this.emitPacket();\n        cb();\n    }\n}\nexports.InterByteTimeoutParser = InterByteTimeoutParser;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,sBAAsB,GAAG,KAAK,CAAC;AACvC,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAClC;AACA;AACA;AACA,MAAMF,sBAAsB,SAASC,QAAQ,CAACE,SAAS,CAAC;EACpDC,WAAW,OAA2D;IAAA,IAA1D;MAAEC,aAAa,GAAG,KAAK;MAAEC,QAAQ;MAAE,GAAGC;IAAiB,CAAC;IAChE,KAAK,CAACA,gBAAgB,CAAC;IACvB,IAAI,CAACD,QAAQ,EAAE;MACX,MAAM,IAAIE,SAAS,CAAC,wBAAwB,CAAC;IACjD;IACA,IAAI,OAAOF,QAAQ,KAAK,QAAQ,IAAIG,MAAM,CAACC,KAAK,CAACJ,QAAQ,CAAC,EAAE;MACxD,MAAM,IAAIE,SAAS,CAAC,4BAA4B,CAAC;IACrD;IACA,IAAIF,QAAQ,GAAG,CAAC,EAAE;MACd,MAAM,IAAIE,SAAS,CAAC,kCAAkC,CAAC;IAC3D;IACA,IAAI,OAAOH,aAAa,KAAK,QAAQ,IAAII,MAAM,CAACC,KAAK,CAACL,aAAa,CAAC,EAAE;MAClE,MAAM,IAAIG,SAAS,CAAC,iCAAiC,CAAC;IAC1D;IACA,IAAIH,aAAa,GAAG,CAAC,EAAE;MACnB,MAAM,IAAIG,SAAS,CAAC,uCAAuC,CAAC;IAChE;IACA,IAAI,CAACH,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACM,aAAa,GAAG,EAAE;IACvB,IAAI,CAACL,QAAQ,GAAGA,QAAQ;EAC5B;EACAM,UAAU,CAACC,KAAK,EAAEC,QAAQ,EAAEC,EAAE,EAAE;IAC5B,IAAI,IAAI,CAACC,UAAU,EAAE;MACjBC,YAAY,CAAC,IAAI,CAACD,UAAU,CAAC;IACjC;IACA,KAAK,IAAIE,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGL,KAAK,CAACM,MAAM,EAAED,MAAM,EAAE,EAAE;MAClD,IAAI,CAACP,aAAa,CAACS,IAAI,CAACP,KAAK,CAACK,MAAM,CAAC,CAAC;MACtC,IAAI,IAAI,CAACP,aAAa,CAACQ,MAAM,IAAI,IAAI,CAACd,aAAa,EAAE;QACjD,IAAI,CAACgB,UAAU,EAAE;MACrB;IACJ;IACA,IAAI,CAACL,UAAU,GAAGM,UAAU,CAAC,IAAI,CAACD,UAAU,CAACE,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAACjB,QAAQ,CAAC;IACvES,EAAE,EAAE;EACR;EACAM,UAAU,GAAG;IACT,IAAI,IAAI,CAACL,UAAU,EAAE;MACjBC,YAAY,CAAC,IAAI,CAACD,UAAU,CAAC;IACjC;IACA,IAAI,IAAI,CAACL,aAAa,CAACQ,MAAM,GAAG,CAAC,EAAE;MAC/B,IAAI,CAACC,IAAI,CAACI,MAAM,CAACC,IAAI,CAAC,IAAI,CAACd,aAAa,CAAC,CAAC;IAC9C;IACA,IAAI,CAACA,aAAa,GAAG,EAAE;EAC3B;EACAe,MAAM,CAACX,EAAE,EAAE;IACP,IAAI,CAACM,UAAU,EAAE;IACjBN,EAAE,EAAE;EACR;AACJ;AACAjB,OAAO,CAACE,sBAAsB,GAAGA,sBAAsB"},"metadata":{},"sourceType":"script","externalDependencies":[]}