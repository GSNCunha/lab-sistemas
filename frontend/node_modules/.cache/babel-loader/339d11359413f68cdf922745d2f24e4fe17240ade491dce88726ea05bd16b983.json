{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SlipDecoder = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that decodes slip encoded data.\n * @extends Transform\n *\n * Runs in O(n) time, stripping out slip encoding and emitting decoded data. Optionally custom slip escape and delimiters can be provided.\n */\nclass SlipDecoder extends stream_1.Transform {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n    const {\n      START,\n      ESC = 0xdb,\n      END = 0xc0,\n      ESC_START,\n      ESC_END = 0xdc,\n      ESC_ESC = 0xdd\n    } = options;\n    this.opts = {\n      START,\n      ESC,\n      END,\n      ESC_START,\n      ESC_END,\n      ESC_ESC\n    };\n    this.buffer = Buffer.alloc(0);\n    this.escape = false;\n    this.start = false;\n  }\n  _transform(chunk, encoding, cb) {\n    for (let ndx = 0; ndx < chunk.length; ndx++) {\n      let byte = chunk[ndx];\n      if (byte === this.opts.START) {\n        this.start = true;\n        continue;\n      } else if (undefined == this.opts.START) {\n        this.start = true;\n      }\n      if (this.escape) {\n        if (byte === this.opts.ESC_START && this.opts.START) {\n          byte = this.opts.START;\n        } else if (byte === this.opts.ESC_ESC) {\n          byte = this.opts.ESC;\n        } else if (byte === this.opts.ESC_END) {\n          byte = this.opts.END;\n        } else {\n          this.escape = false;\n          this.push(this.buffer);\n          this.buffer = Buffer.alloc(0);\n        }\n      } else {\n        if (byte === this.opts.ESC) {\n          this.escape = true;\n          continue;\n        }\n        if (byte === this.opts.END) {\n          this.push(this.buffer);\n          this.buffer = Buffer.alloc(0);\n          this.escape = false;\n          this.start = false;\n          continue;\n        }\n      }\n      this.escape = false;\n      if (this.start) {\n        this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);\n      }\n    }\n    cb();\n  }\n  _flush(cb) {\n    this.push(this.buffer);\n    this.buffer = Buffer.alloc(0);\n    cb();\n  }\n}\nexports.SlipDecoder = SlipDecoder;","map":{"version":3,"names":["Object","defineProperty","exports","value","SlipDecoder","stream_1","require","Transform","constructor","options","START","ESC","END","ESC_START","ESC_END","ESC_ESC","opts","buffer","Buffer","alloc","escape","start","_transform","chunk","encoding","cb","ndx","length","byte","undefined","push","concat","from","_flush"],"sources":["/Users/code/Desktop/WEB/lab-sistemas/frontend/node_modules/@serialport/parser-slip-encoder/dist/decoder.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SlipDecoder = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that decodes slip encoded data.\n * @extends Transform\n *\n * Runs in O(n) time, stripping out slip encoding and emitting decoded data. Optionally custom slip escape and delimiters can be provided.\n */\nclass SlipDecoder extends stream_1.Transform {\n    constructor(options = {}) {\n        super(options);\n        const { START, ESC = 0xdb, END = 0xc0, ESC_START, ESC_END = 0xdc, ESC_ESC = 0xdd } = options;\n        this.opts = {\n            START,\n            ESC,\n            END,\n            ESC_START,\n            ESC_END,\n            ESC_ESC,\n        };\n        this.buffer = Buffer.alloc(0);\n        this.escape = false;\n        this.start = false;\n    }\n    _transform(chunk, encoding, cb) {\n        for (let ndx = 0; ndx < chunk.length; ndx++) {\n            let byte = chunk[ndx];\n            if (byte === this.opts.START) {\n                this.start = true;\n                continue;\n            }\n            else if (undefined == this.opts.START) {\n                this.start = true;\n            }\n            if (this.escape) {\n                if (byte === this.opts.ESC_START && this.opts.START) {\n                    byte = this.opts.START;\n                }\n                else if (byte === this.opts.ESC_ESC) {\n                    byte = this.opts.ESC;\n                }\n                else if (byte === this.opts.ESC_END) {\n                    byte = this.opts.END;\n                }\n                else {\n                    this.escape = false;\n                    this.push(this.buffer);\n                    this.buffer = Buffer.alloc(0);\n                }\n            }\n            else {\n                if (byte === this.opts.ESC) {\n                    this.escape = true;\n                    continue;\n                }\n                if (byte === this.opts.END) {\n                    this.push(this.buffer);\n                    this.buffer = Buffer.alloc(0);\n                    this.escape = false;\n                    this.start = false;\n                    continue;\n                }\n            }\n            this.escape = false;\n            if (this.start) {\n                this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);\n            }\n        }\n        cb();\n    }\n    _flush(cb) {\n        this.push(this.buffer);\n        this.buffer = Buffer.alloc(0);\n        cb();\n    }\n}\nexports.SlipDecoder = SlipDecoder;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}